{"searchDocs":[{"title":"Getting Started","type":0,"sectionRef":"#","url":"/Structix/docs/intro","content":"","keywords":"","version":"Next"},{"title":"Pre-Requisiteâ€‹","type":1,"pageTitle":"Getting Started","url":"/Structix/docs/intro#pre-requisite","content":" Structix started as a simple side project something I didnâ€™t expect to go far with. If you're unfamiliar with any of the data structures showcased here, or if you're not sure how they work or what theyâ€™re for, I recommend taking a moment to research them online. A solid understanding of their general behavior and use cases will help you get the most out of this library. If you're still with me, great. Iâ€™ll do my best to explain each structure and how it functions within Structix â†’ Dive Into The Concepts   ","version":"Next","tagName":"h2"},{"title":"Pros","type":0,"sectionRef":"#","url":"/Structix/docs/Pros&Cons/pros","content":"Pros ğŸ”’Strict Typing &amp; API Safety Structix somewhat enforces strict types, reducing runtime errors and catches mistakes early making it great for any scale projects.ğŸ“–Readable, Maintainable Code We love readable code!âš™ï¸Customizable Behavior Support for modes, comparators, and features like min/max in (Heap, Priority Queue) which lets you tailor performance and logic to your needs.ğŸ“‹Unified Interface Consistent methods like size, clear, copy across all structures reduce the learning curve and makes it easy to compare structure sizes/copies.ğŸŒ€Safe Cloning &amp; Equality API Built in copy/equality methods making it safe and easy to copy/compare the structures.","keywords":"","version":"Next"},{"title":"Collection","type":0,"sectionRef":"#","url":"/Structix/api/Collection","content":"Collection Collection class","keywords":"","version":null},{"title":"Cons","type":0,"sectionRef":"#","url":"/Structix/docs/Pros&Cons/cons","content":"Cons ğŸ¢Slight Overhead Wrapper functions add some performance and memory cost compared to raw tables, though negligible in most cases.ğŸ“˜Learning Curve Beginners unfamiliar with data structures like trees or dequeues might need some time to understand and when to use them.ğŸš«Unnecessary Structures Most of these data structures you'll find unnecessary in development because it needs to have a very specific usecase. Roblox games typically only need structures like arrays, dictionaries to function.ğŸ”„Manual Replication Structix data is local to memory, meaning you'll need to handle syncing between client/server manually if needed.ğŸª¶Not Always Relevant For very small, temporary, or throwaway data sets, plain roblox tables might be simpler and faster to use.","keywords":"","version":"Next"},{"title":"Concepts","type":0,"sectionRef":"#","url":"/Structix/docs/concepts","content":"","keywords":"","version":"Next"},{"title":"Binary Treeâ€‹","type":1,"pageTitle":"Concepts","url":"/Structix/docs/concepts#binary-tree","content":" A Binary Tree branches like a decision tree. Each node has two children: left and right. When ordered, it becomes a Binary Search Tree, which makes lookups fast. Trees model hierarchies, expressions, file systems, and even spatial zones in games. Learn More About Binary Trees    ","version":"Next","tagName":"h2"},{"title":"Collectionâ€‹","type":1,"pageTitle":"Concepts","url":"/Structix/docs/concepts#collection","content":" A Collection is a flexible, ordered group of items like a dynamic array. It gives you tools to manipulate, iterate, and transform values in bulk. Think of it as a friendly workspace for general-purpose list processing, filtering, and reshaping data. Learn More About Collections    ","version":"Next","tagName":"h2"},{"title":"Dequeâ€‹","type":1,"pageTitle":"Concepts","url":"/Structix/docs/concepts#deque","content":" A Deque (also known as a Double Ended Queue) gives you control at both ends. You can add or remove items from the front or back. Itâ€™s flexible and ideal when you need both stack and queue behaviors think of it as a two-way street for data flow. Learn More About Deques    ","version":"Next","tagName":"h2"},{"title":"Heapâ€‹","type":1,"pageTitle":"Concepts","url":"/Structix/docs/concepts#heap","content":" A Heap keeps the most important item (according to your rules) at the top. In a min-heap, the smallest item rises. In a max-heap, the largest does. Heaps power efficient priority management like job schedulers and pathfinding. Learn More About Heaps    ","version":"Next","tagName":"h2"},{"title":"Linked Listâ€‹","type":1,"pageTitle":"Concepts","url":"/Structix/docs/concepts#linked-list","content":" A LinkedList connects data like a chain. Each piece points to the next (and sometimes the previous). Itâ€™s not fast for random access but excels at efficient insertions and deletions especially in the middle. Use it when flexibility beats speed. Learn More About Linked Lists    ","version":"Next","tagName":"h2"},{"title":"Mapâ€‹","type":1,"pageTitle":"Concepts","url":"/Structix/docs/concepts#map","content":" A Map (or dictionary) links keys to values. You use a key to retrieve its paired value. Itâ€™s ideal for storing associations like a username mapped to a score, or an item ID mapped to its description. Maps are essential for fast lookups. Learn More About Maps    ","version":"Next","tagName":"h2"},{"title":"Priority Queueâ€‹","type":1,"pageTitle":"Concepts","url":"/Structix/docs/concepts#priority-queue","content":" A PriorityQueue is like a line where some people are allowed to cut in front based on urgency. Each element has a priority. The queue always serves the most critical item first. It's a higher-level abstraction built on a heap, perfect for game events, task queues, or AI decision systems. Learn More About Priority Queues    ","version":"Next","tagName":"h2"},{"title":"Queueâ€‹","type":1,"pageTitle":"Concepts","url":"/Structix/docs/concepts#queue","content":" A Queue is a line of people waiting their turn. It follows First-In, First-Out (FIFO). The first element in is the first to be removed. Queues are perfect for scheduling, turn-based logic, and managing sequences where order matters. Learn More About Queues    ","version":"Next","tagName":"h2"},{"title":"Setâ€‹","type":1,"pageTitle":"Concepts","url":"/Structix/docs/concepts#set","content":" A Set is a collection of unique items. No duplicates allowed. Itâ€™s great for checking membership, enforcing uniqueness, and doing operations like unions, intersections, and differences just like in mathematics. Learn More About Sets    ","version":"Next","tagName":"h2"},{"title":"Stackâ€‹","type":1,"pageTitle":"Concepts","url":"/Structix/docs/concepts#stack","content":" A Stack is like a stack of plates: the last one you put on is the first one you take off. It follows the Last-In, First-Out (LIFO) principle. Use it when you need to undo actions, backtrack, or manage nested operations like call stacks in programming or game state rewinds. Learn More About Stacks   ","version":"Next","tagName":"h2"},{"title":"BinaryTree","type":0,"sectionRef":"#","url":"/Structix/api/BinaryTree","content":"","keywords":"","version":null},{"title":"Functionsâ€‹","type":1,"pageTitle":"BinaryTree","url":"/Structix/api/BinaryTree#functions","content":" ","version":null,"tagName":"h2"},{"title":"newâ€‹","type":1,"pageTitle":"BinaryTree","url":"/Structix/api/BinaryTree#new","content":"&lt;/&gt; BinaryTree.new() â†’Â BinaryTreeType&lt;T&gt;-- Empty binary tree instance. Creates a new empty binary tree.  ","version":null,"tagName":"h3"},{"title":"getBinaryTreeâ€‹","type":1,"pageTitle":"BinaryTree","url":"/Structix/api/BinaryTree#getBinaryTree","content":"&lt;/&gt; BinaryTree.getBinaryTree(self:Â InternalBinaryTree&lt;T&gt;) â†’Â {T}-- An array containing all values in pre-order. Returns the full contents of the binary tree in pre-order (root-left-right) traversal.  ","version":null,"tagName":"h3"},{"title":"sizeâ€‹","type":1,"pageTitle":"BinaryTree","url":"/Structix/api/BinaryTree#size","content":"&lt;/&gt; BinaryTree.size(self:Â InternalBinaryTree&lt;T&gt;) â†’Â number-- The number of elements currently in the tree. Returns the number of elements in the binary tree.  ","version":null,"tagName":"h3"},{"title":"copyâ€‹","type":1,"pageTitle":"BinaryTree","url":"/Structix/api/BinaryTree#copy","content":"&lt;/&gt; BinaryTree.copy(self:Â InternalBinaryTree&lt;T&gt;) â†’Â BinaryTreeType&lt;T&gt;-- A new binary tree containing all elements from the original. Creates a deep copy of the binary tree. If binary tree is empty, it will error.  ","version":null,"tagName":"h3"},{"title":"clearâ€‹","type":1,"pageTitle":"BinaryTree","url":"/Structix/api/BinaryTree#clear","content":"&lt;/&gt; BinaryTree.clear(self:Â InternalBinaryTree&lt;T&gt;) â†’Â () Removes all elements from the binary tree.  ","version":null,"tagName":"h3"},{"title":"insertâ€‹","type":1,"pageTitle":"BinaryTree","url":"/Structix/api/BinaryTree#insert","content":"&lt;/&gt; BinaryTree.insert( self:Â InternalBinaryTree&lt;T&gt;, value:Â T-- The value to insert into the tree. ) â†’Â () Inserts a new value into the binary tree, preserving the binary search tree property.  ","version":null,"tagName":"h3"},{"title":"containsâ€‹","type":1,"pageTitle":"BinaryTree","url":"/Structix/api/BinaryTree#contains","content":"&lt;/&gt; BinaryTree.contains( self:Â InternalBinaryTree&lt;T&gt;, value:Â T-- The value to search for. ) â†’Â boolean-- true if the value exists in the tree, otherwise false. Checks whether a value exists in the tree.  ","version":null,"tagName":"h3"},{"title":"removeâ€‹","type":1,"pageTitle":"BinaryTree","url":"/Structix/api/BinaryTree#remove","content":"&lt;/&gt; BinaryTree.remove( self:Â InternalBinaryTree&lt;T&gt;, value:Â T-- The value to remove from the tree. ) â†’Â () Removes a value from the binary tree if it exists. Will warn if the value is not in the binary tree.  ","version":null,"tagName":"h3"},{"title":"minâ€‹","type":1,"pageTitle":"BinaryTree","url":"/Structix/api/BinaryTree#min","content":"&lt;/&gt; BinaryTree.min(self:Â InternalBinaryTree&lt;T&gt;) â†’Â T?-- The minimum value, or nil if the tree is empty. Returns the smallest value in the binary tree.  ","version":null,"tagName":"h3"},{"title":"maxâ€‹","type":1,"pageTitle":"BinaryTree","url":"/Structix/api/BinaryTree#max","content":"&lt;/&gt; BinaryTree.max(self:Â InternalBinaryTree&lt;T&gt;) â†’Â T?-- The maximum value, or nil if the tree is empty. Returns the largest value in the binary tree.  ","version":null,"tagName":"h3"},{"title":"heightâ€‹","type":1,"pageTitle":"BinaryTree","url":"/Structix/api/BinaryTree#height","content":"&lt;/&gt; BinaryTree.height(self:Â InternalBinaryTree&lt;T&gt;) â†’Â number-- The height of the tree (max depth). Returns -1 if the tree is empty. Calculates the height of the binary tree.  ","version":null,"tagName":"h3"},{"title":"traverseInOrderâ€‹","type":1,"pageTitle":"BinaryTree","url":"/Structix/api/BinaryTree#traverseInOrder","content":"&lt;/&gt; BinaryTree.traverseInOrder(self:Â InternalBinaryTree&lt;T&gt;) â†’Â {T}-- Array of values in in-order traversal. Returns an in-order (left-root-right) traversal of the tree.  ","version":null,"tagName":"h3"},{"title":"traversePreOrderâ€‹","type":1,"pageTitle":"BinaryTree","url":"/Structix/api/BinaryTree#traversePreOrder","content":"&lt;/&gt; BinaryTree.traversePreOrder(self:Â InternalBinaryTree&lt;T&gt;) â†’Â {T}-- Array of values in pre-order traversal. Returns a pre-order (root-left-right) traversal of the tree.  ","version":null,"tagName":"h3"},{"title":"traversePostOrderâ€‹","type":1,"pageTitle":"BinaryTree","url":"/Structix/api/BinaryTree#traversePostOrder","content":"&lt;/&gt; BinaryTree.traversePostOrder(self:Â InternalBinaryTree&lt;T&gt;) â†’Â {T}-- Array of values in post-order traversal. Returns a post-order (left-right-root) traversal of the tree. ","version":null,"tagName":"h3"}],"options":{"id":"default"}}